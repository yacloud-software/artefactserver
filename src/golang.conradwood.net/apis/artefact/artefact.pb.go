// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/artefact/artefact.proto
// DO NOT EDIT!

/*
Package artefact is a generated protocol buffer package.

It is generated from these files:
	protos/golang.conradwood.net/apis/artefact/artefact.proto

It has these top-level messages:
	ArtefactList
	DownloadRequest
	FileStream
	Reference
	ArtefactRef
	SerialReference
	Contents
	SetAccessRequest
	FindRequest
	GetVersionRequest
	BuildList
	DirListRequest
	FileRequest
	FileInfo
	DirInfo
	ArtefactInfo
	DirListing
	FileStreamResponse
	FileExistsInfo
	ID
	ArtefactID
	ArtefactMeta
	CreateArtefactRequest
	CreateArtefactResponse
*/
package artefact

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import h2gproxy "golang.conradwood.net/apis/h2gproxy"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ContentType int32

const (
	ContentType_Directory ContentType = 0
	ContentType_File      ContentType = 1
	ContentType_Artefact  ContentType = 2
)

var ContentType_name = map[int32]string{
	0: "Directory",
	1: "File",
	2: "Artefact",
}
var ContentType_value = map[string]int32{
	"Directory": 0,
	"File":      1,
	"Artefact":  2,
}

func (x ContentType) String() string {
	return proto.EnumName(ContentType_name, int32(x))
}
func (ContentType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ArtefactList struct {
	Artefacts []*Contents `protobuf:"bytes,1,rep,name=Artefacts" json:"Artefacts,omitempty"`
}

func (m *ArtefactList) Reset()                    { *m = ArtefactList{} }
func (m *ArtefactList) String() string            { return proto.CompactTextString(m) }
func (*ArtefactList) ProtoMessage()               {}
func (*ArtefactList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ArtefactList) GetArtefacts() []*Contents {
	if m != nil {
		return m.Artefacts
	}
	return nil
}

type DownloadRequest struct {
	Reference string `protobuf:"bytes,1,opt,name=Reference" json:"Reference,omitempty"`
}

func (m *DownloadRequest) Reset()                    { *m = DownloadRequest{} }
func (m *DownloadRequest) String() string            { return proto.CompactTextString(m) }
func (*DownloadRequest) ProtoMessage()               {}
func (*DownloadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DownloadRequest) GetReference() string {
	if m != nil {
		return m.Reference
	}
	return ""
}

type FileStream struct {
	Data []byte `protobuf:"bytes,1,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *FileStream) Reset()                    { *m = FileStream{} }
func (m *FileStream) String() string            { return proto.CompactTextString(m) }
func (*FileStream) ProtoMessage()               {}
func (*FileStream) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *FileStream) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Reference struct {
	Reference string `protobuf:"bytes,1,opt,name=Reference" json:"Reference,omitempty"`
}

func (m *Reference) Reset()                    { *m = Reference{} }
func (m *Reference) String() string            { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()               {}
func (*Reference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Reference) GetReference() string {
	if m != nil {
		return m.Reference
	}
	return ""
}

type ArtefactRef struct {
	Name    string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Version uint64 `protobuf:"varint,2,opt,name=Version" json:"Version,omitempty"`
}

func (m *ArtefactRef) Reset()                    { *m = ArtefactRef{} }
func (m *ArtefactRef) String() string            { return proto.CompactTextString(m) }
func (*ArtefactRef) ProtoMessage()               {}
func (*ArtefactRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ArtefactRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ArtefactRef) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type SerialReference struct {
	RefType   uint32   `protobuf:"varint,1,opt,name=RefType" json:"RefType,omitempty"`
	Version   uint64   `protobuf:"varint,2,opt,name=Version" json:"Version,omitempty"`
	Texts     []string `protobuf:"bytes,3,rep,name=Texts" json:"Texts,omitempty"`
	Domain    string   `protobuf:"bytes,4,opt,name=Domain" json:"Domain,omitempty"`
	BuildRepo string   `protobuf:"bytes,5,opt,name=BuildRepo" json:"BuildRepo,omitempty"`
}

func (m *SerialReference) Reset()                    { *m = SerialReference{} }
func (m *SerialReference) String() string            { return proto.CompactTextString(m) }
func (*SerialReference) ProtoMessage()               {}
func (*SerialReference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SerialReference) GetRefType() uint32 {
	if m != nil {
		return m.RefType
	}
	return 0
}

func (m *SerialReference) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SerialReference) GetTexts() []string {
	if m != nil {
		return m.Texts
	}
	return nil
}

func (m *SerialReference) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *SerialReference) GetBuildRepo() string {
	if m != nil {
		return m.BuildRepo
	}
	return ""
}

type Contents struct {
	ReferenceVersion string       `protobuf:"bytes,1,opt,name=ReferenceVersion" json:"ReferenceVersion,omitempty"`
	ReferenceLatest  string       `protobuf:"bytes,2,opt,name=ReferenceLatest" json:"ReferenceLatest,omitempty"`
	Entries          []*Contents  `protobuf:"bytes,3,rep,name=Entries" json:"Entries,omitempty"`
	Name             string       `protobuf:"bytes,4,opt,name=Name" json:"Name,omitempty"`
	Version          uint64       `protobuf:"varint,5,opt,name=Version" json:"Version,omitempty"`
	AdminAccess      bool         `protobuf:"varint,6,opt,name=AdminAccess" json:"AdminAccess,omitempty"`
	Type             ContentType  `protobuf:"varint,7,opt,name=Type,enum=artefact.ContentType" json:"Type,omitempty"`
	Artefact         *ArtefactRef `protobuf:"bytes,8,opt,name=Artefact" json:"Artefact,omitempty"`
	Path             string       `protobuf:"bytes,9,opt,name=Path" json:"Path,omitempty"`
	Downloadable     bool         `protobuf:"varint,10,opt,name=Downloadable" json:"Downloadable,omitempty"`
	// the name of an artefact is not entirely sufficient. we may have multiple buildrepo servers too
	Domain        string      `protobuf:"bytes,11,opt,name=Domain" json:"Domain,omitempty"`
	ArtefactID    *ArtefactID `protobuf:"bytes,12,opt,name=ArtefactID" json:"ArtefactID,omitempty"`
	BuildRepo     string      `protobuf:"bytes,13,opt,name=BuildRepo" json:"BuildRepo,omitempty"`
	RepositoryID  uint64      `protobuf:"varint,14,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	LinkToVersion string      `protobuf:"bytes,15,opt,name=LinkToVersion" json:"LinkToVersion,omitempty"`
	LinkToLatest  string      `protobuf:"bytes,16,opt,name=LinkToLatest" json:"LinkToLatest,omitempty"`
}

func (m *Contents) Reset()                    { *m = Contents{} }
func (m *Contents) String() string            { return proto.CompactTextString(m) }
func (*Contents) ProtoMessage()               {}
func (*Contents) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Contents) GetReferenceVersion() string {
	if m != nil {
		return m.ReferenceVersion
	}
	return ""
}

func (m *Contents) GetReferenceLatest() string {
	if m != nil {
		return m.ReferenceLatest
	}
	return ""
}

func (m *Contents) GetEntries() []*Contents {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *Contents) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Contents) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Contents) GetAdminAccess() bool {
	if m != nil {
		return m.AdminAccess
	}
	return false
}

func (m *Contents) GetType() ContentType {
	if m != nil {
		return m.Type
	}
	return ContentType_Directory
}

func (m *Contents) GetArtefact() *ArtefactRef {
	if m != nil {
		return m.Artefact
	}
	return nil
}

func (m *Contents) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Contents) GetDownloadable() bool {
	if m != nil {
		return m.Downloadable
	}
	return false
}

func (m *Contents) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Contents) GetArtefactID() *ArtefactID {
	if m != nil {
		return m.ArtefactID
	}
	return nil
}

func (m *Contents) GetBuildRepo() string {
	if m != nil {
		return m.BuildRepo
	}
	return ""
}

func (m *Contents) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *Contents) GetLinkToVersion() string {
	if m != nil {
		return m.LinkToVersion
	}
	return ""
}

func (m *Contents) GetLinkToLatest() string {
	if m != nil {
		return m.LinkToLatest
	}
	return ""
}

type SetAccessRequest struct {
	Target *Reference `protobuf:"bytes,1,opt,name=Target" json:"Target,omitempty"`
	UserID string     `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	Grant  bool       `protobuf:"varint,3,opt,name=Grant" json:"Grant,omitempty"`
}

func (m *SetAccessRequest) Reset()                    { *m = SetAccessRequest{} }
func (m *SetAccessRequest) String() string            { return proto.CompactTextString(m) }
func (*SetAccessRequest) ProtoMessage()               {}
func (*SetAccessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SetAccessRequest) GetTarget() *Reference {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *SetAccessRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *SetAccessRequest) GetGrant() bool {
	if m != nil {
		return m.Grant
	}
	return false
}

type FindRequest struct {
	// only return results containing this
	NameMatch string `protobuf:"bytes,1,opt,name=NameMatch" json:"NameMatch,omitempty"`
}

func (m *FindRequest) Reset()                    { *m = FindRequest{} }
func (m *FindRequest) String() string            { return proto.CompactTextString(m) }
func (*FindRequest) ProtoMessage()               {}
func (*FindRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *FindRequest) GetNameMatch() string {
	if m != nil {
		return m.NameMatch
	}
	return ""
}

type GetVersionRequest struct {
	Name    string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Domain  string `protobuf:"bytes,2,opt,name=Domain" json:"Domain,omitempty"`
	Version uint64 `protobuf:"varint,3,opt,name=Version" json:"Version,omitempty"`
}

func (m *GetVersionRequest) Reset()                    { *m = GetVersionRequest{} }
func (m *GetVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*GetVersionRequest) ProtoMessage()               {}
func (*GetVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *GetVersionRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetVersionRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *GetVersionRequest) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type BuildList struct {
	Builds []uint64 `protobuf:"varint,1,rep,packed,name=Builds" json:"Builds,omitempty"`
}

func (m *BuildList) Reset()                    { *m = BuildList{} }
func (m *BuildList) String() string            { return proto.CompactTextString(m) }
func (*BuildList) ProtoMessage()               {}
func (*BuildList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *BuildList) GetBuilds() []uint64 {
	if m != nil {
		return m.Builds
	}
	return nil
}

type DirListRequest struct {
	Build      uint64 `protobuf:"varint,1,opt,name=Build" json:"Build,omitempty"`
	Dir        string `protobuf:"bytes,2,opt,name=Dir" json:"Dir,omitempty"`
	ArtefactID uint64 `protobuf:"varint,3,opt,name=ArtefactID" json:"ArtefactID,omitempty"`
}

func (m *DirListRequest) Reset()                    { *m = DirListRequest{} }
func (m *DirListRequest) String() string            { return proto.CompactTextString(m) }
func (*DirListRequest) ProtoMessage()               {}
func (*DirListRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *DirListRequest) GetBuild() uint64 {
	if m != nil {
		return m.Build
	}
	return 0
}

func (m *DirListRequest) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *DirListRequest) GetArtefactID() uint64 {
	if m != nil {
		return m.ArtefactID
	}
	return 0
}

type FileRequest struct {
	ArtefactID uint64 `protobuf:"varint,1,opt,name=ArtefactID" json:"ArtefactID,omitempty"`
	Build      uint64 `protobuf:"varint,2,opt,name=Build" json:"Build,omitempty"`
	Filename   string `protobuf:"bytes,3,opt,name=Filename" json:"Filename,omitempty"`
}

func (m *FileRequest) Reset()                    { *m = FileRequest{} }
func (m *FileRequest) String() string            { return proto.CompactTextString(m) }
func (*FileRequest) ProtoMessage()               {}
func (*FileRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *FileRequest) GetArtefactID() uint64 {
	if m != nil {
		return m.ArtefactID
	}
	return 0
}

func (m *FileRequest) GetBuild() uint64 {
	if m != nil {
		return m.Build
	}
	return 0
}

func (m *FileRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

type FileInfo struct {
	Name        string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	RelativeDir string `protobuf:"bytes,2,opt,name=RelativeDir" json:"RelativeDir,omitempty"`
}

func (m *FileInfo) Reset()                    { *m = FileInfo{} }
func (m *FileInfo) String() string            { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()               {}
func (*FileInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *FileInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileInfo) GetRelativeDir() string {
	if m != nil {
		return m.RelativeDir
	}
	return ""
}

type DirInfo struct {
	Name        string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	RelativeDir string `protobuf:"bytes,2,opt,name=RelativeDir" json:"RelativeDir,omitempty"`
}

func (m *DirInfo) Reset()                    { *m = DirInfo{} }
func (m *DirInfo) String() string            { return proto.CompactTextString(m) }
func (*DirInfo) ProtoMessage()               {}
func (*DirInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *DirInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DirInfo) GetRelativeDir() string {
	if m != nil {
		return m.RelativeDir
	}
	return ""
}

type ArtefactInfo struct {
	ID   uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
}

func (m *ArtefactInfo) Reset()                    { *m = ArtefactInfo{} }
func (m *ArtefactInfo) String() string            { return proto.CompactTextString(m) }
func (*ArtefactInfo) ProtoMessage()               {}
func (*ArtefactInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ArtefactInfo) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ArtefactInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type DirListing struct {
	Files        []*FileInfo   `protobuf:"bytes,1,rep,name=Files" json:"Files,omitempty"`
	Dirs         []*DirInfo    `protobuf:"bytes,2,rep,name=Dirs" json:"Dirs,omitempty"`
	ArtefactInfo *ArtefactInfo `protobuf:"bytes,3,opt,name=ArtefactInfo" json:"ArtefactInfo,omitempty"`
	Path         string        `protobuf:"bytes,4,opt,name=Path" json:"Path,omitempty"`
}

func (m *DirListing) Reset()                    { *m = DirListing{} }
func (m *DirListing) String() string            { return proto.CompactTextString(m) }
func (*DirListing) ProtoMessage()               {}
func (*DirListing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *DirListing) GetFiles() []*FileInfo {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *DirListing) GetDirs() []*DirInfo {
	if m != nil {
		return m.Dirs
	}
	return nil
}

func (m *DirListing) GetArtefactInfo() *ArtefactInfo {
	if m != nil {
		return m.ArtefactInfo
	}
	return nil
}

func (m *DirListing) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type FileStreamResponse struct {
	Filesize uint64 `protobuf:"varint,1,opt,name=Filesize" json:"Filesize,omitempty"`
	Payload  []byte `protobuf:"bytes,2,opt,name=Payload,proto3" json:"Payload,omitempty"`
}

func (m *FileStreamResponse) Reset()                    { *m = FileStreamResponse{} }
func (m *FileStreamResponse) String() string            { return proto.CompactTextString(m) }
func (*FileStreamResponse) ProtoMessage()               {}
func (*FileStreamResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *FileStreamResponse) GetFilesize() uint64 {
	if m != nil {
		return m.Filesize
	}
	return 0
}

func (m *FileStreamResponse) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type FileExistsInfo struct {
	Exists bool   `protobuf:"varint,1,opt,name=Exists" json:"Exists,omitempty"`
	Size   uint64 `protobuf:"varint,2,opt,name=Size" json:"Size,omitempty"`
}

func (m *FileExistsInfo) Reset()                    { *m = FileExistsInfo{} }
func (m *FileExistsInfo) String() string            { return proto.CompactTextString(m) }
func (*FileExistsInfo) ProtoMessage()               {}
func (*FileExistsInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *FileExistsInfo) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

func (m *FileExistsInfo) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

type ID struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *ID) Reset()                    { *m = ID{} }
func (m *ID) String() string            { return proto.CompactTextString(m) }
func (*ID) ProtoMessage()               {}
func (*ID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *ID) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// for database, stores meta information about artefacts
type ArtefactID struct {
	ID     uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Domain string `protobuf:"bytes,2,opt,name=Domain" json:"Domain,omitempty"`
	Name   string `protobuf:"bytes,3,opt,name=Name" json:"Name,omitempty"`
	URL    string `protobuf:"bytes,4,opt,name=URL" json:"URL,omitempty"`
}

func (m *ArtefactID) Reset()                    { *m = ArtefactID{} }
func (m *ArtefactID) String() string            { return proto.CompactTextString(m) }
func (*ArtefactID) ProtoMessage()               {}
func (*ArtefactID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *ArtefactID) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ArtefactID) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *ArtefactID) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ArtefactID) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

// metadata about an artefact
type ArtefactMeta struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *ArtefactMeta) Reset()                    { *m = ArtefactMeta{} }
func (m *ArtefactMeta) String() string            { return proto.CompactTextString(m) }
func (*ArtefactMeta) ProtoMessage()               {}
func (*ArtefactMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *ArtefactMeta) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type CreateArtefactRequest struct {
	OrganisationID  string `protobuf:"bytes,1,opt,name=OrganisationID" json:"OrganisationID,omitempty"`
	ArtefactName    string `protobuf:"bytes,2,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
	BuildRepoDomain string `protobuf:"bytes,3,opt,name=BuildRepoDomain" json:"BuildRepoDomain,omitempty"`
	GitURL          string `protobuf:"bytes,4,opt,name=GitURL" json:"GitURL,omitempty"`
}

func (m *CreateArtefactRequest) Reset()                    { *m = CreateArtefactRequest{} }
func (m *CreateArtefactRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateArtefactRequest) ProtoMessage()               {}
func (*CreateArtefactRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *CreateArtefactRequest) GetOrganisationID() string {
	if m != nil {
		return m.OrganisationID
	}
	return ""
}

func (m *CreateArtefactRequest) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

func (m *CreateArtefactRequest) GetBuildRepoDomain() string {
	if m != nil {
		return m.BuildRepoDomain
	}
	return ""
}

func (m *CreateArtefactRequest) GetGitURL() string {
	if m != nil {
		return m.GitURL
	}
	return ""
}

type CreateArtefactResponse struct {
	Created bool          `protobuf:"varint,1,opt,name=Created" json:"Created,omitempty"`
	Meta    *ArtefactMeta `protobuf:"bytes,2,opt,name=Meta" json:"Meta,omitempty"`
}

func (m *CreateArtefactResponse) Reset()                    { *m = CreateArtefactResponse{} }
func (m *CreateArtefactResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateArtefactResponse) ProtoMessage()               {}
func (*CreateArtefactResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *CreateArtefactResponse) GetCreated() bool {
	if m != nil {
		return m.Created
	}
	return false
}

func (m *CreateArtefactResponse) GetMeta() *ArtefactMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func init() {
	proto.RegisterType((*ArtefactList)(nil), "artefact.ArtefactList")
	proto.RegisterType((*DownloadRequest)(nil), "artefact.DownloadRequest")
	proto.RegisterType((*FileStream)(nil), "artefact.FileStream")
	proto.RegisterType((*Reference)(nil), "artefact.Reference")
	proto.RegisterType((*ArtefactRef)(nil), "artefact.ArtefactRef")
	proto.RegisterType((*SerialReference)(nil), "artefact.SerialReference")
	proto.RegisterType((*Contents)(nil), "artefact.Contents")
	proto.RegisterType((*SetAccessRequest)(nil), "artefact.SetAccessRequest")
	proto.RegisterType((*FindRequest)(nil), "artefact.FindRequest")
	proto.RegisterType((*GetVersionRequest)(nil), "artefact.GetVersionRequest")
	proto.RegisterType((*BuildList)(nil), "artefact.BuildList")
	proto.RegisterType((*DirListRequest)(nil), "artefact.DirListRequest")
	proto.RegisterType((*FileRequest)(nil), "artefact.FileRequest")
	proto.RegisterType((*FileInfo)(nil), "artefact.FileInfo")
	proto.RegisterType((*DirInfo)(nil), "artefact.DirInfo")
	proto.RegisterType((*ArtefactInfo)(nil), "artefact.ArtefactInfo")
	proto.RegisterType((*DirListing)(nil), "artefact.DirListing")
	proto.RegisterType((*FileStreamResponse)(nil), "artefact.FileStreamResponse")
	proto.RegisterType((*FileExistsInfo)(nil), "artefact.FileExistsInfo")
	proto.RegisterType((*ID)(nil), "artefact.ID")
	proto.RegisterType((*ArtefactID)(nil), "artefact.ArtefactID")
	proto.RegisterType((*ArtefactMeta)(nil), "artefact.ArtefactMeta")
	proto.RegisterType((*CreateArtefactRequest)(nil), "artefact.CreateArtefactRequest")
	proto.RegisterType((*CreateArtefactResponse)(nil), "artefact.CreateArtefactResponse")
	proto.RegisterEnum("artefact.ContentType", ContentType_name, ContentType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ArtefactService service

type ArtefactServiceClient interface {
	// list *latest* version of all artefacts (for this user)
	List(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*ArtefactList, error)
	// get contents of a directory or artefact.
	GetContents(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Contents, error)
	// download a file via http
	StreamHTTP(ctx context.Context, in *h2gproxy.StreamRequest, opts ...grpc.CallOption) (ArtefactService_StreamHTTPClient, error)
	// download a file via gRPC stream
	GetFile(ctx context.Context, in *Reference, opts ...grpc.CallOption) (ArtefactService_GetFileClient, error)
	// set access to a repo/artefact
	SetAccess(ctx context.Context, in *SetAccessRequest, opts ...grpc.CallOption) (*common.Void, error)
	// finds artefacts based on fuzzy string matches
	Find(ctx context.Context, in *FindRequest, opts ...grpc.CallOption) (*ArtefactList, error)
	// get a specific version of a repository
	GetRepoVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*Contents, error)
	// get builds for a given artefact
	GetArtefactBuilds(ctx context.Context, in *ArtefactID, opts ...grpc.CallOption) (*BuildList, error)
	// get list of files for a given artefact, build and directory
	GetDirListing(ctx context.Context, in *DirListRequest, opts ...grpc.CallOption) (*DirListing, error)
	// get a file as stream
	GetFileStream(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (ArtefactService_GetFileStreamClient, error)
	// does file exist
	DoesFileExist(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (*FileExistsInfo, error)
	// get which repo fed this artefact
	GetRepoForArtefact(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ID, error)
	// get an artefact for a given repo
	GetArtefactForRepo(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ID, error)
	// get an artefact for a given repo
	GetArtefactByID(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ArtefactID, error)
	// get an artefactid for a given repo
	GetArtefactIDForRepo(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ArtefactID, error)
	// get artefact metadata by artefactid
	MetaByID(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ArtefactMeta, error)
	// create artefact if required. if it exists already it will not be recreated. URL may be added or updated
	CreateArtefactIfRequired(ctx context.Context, in *CreateArtefactRequest, opts ...grpc.CallOption) (*CreateArtefactResponse, error)
}

type artefactServiceClient struct {
	cc *grpc.ClientConn
}

func NewArtefactServiceClient(cc *grpc.ClientConn) ArtefactServiceClient {
	return &artefactServiceClient{cc}
}

func (c *artefactServiceClient) List(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*ArtefactList, error) {
	out := new(ArtefactList)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) GetContents(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Contents, error) {
	out := new(Contents)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/GetContents", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) StreamHTTP(ctx context.Context, in *h2gproxy.StreamRequest, opts ...grpc.CallOption) (ArtefactService_StreamHTTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ArtefactService_serviceDesc.Streams[0], c.cc, "/artefact.ArtefactService/StreamHTTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &artefactServiceStreamHTTPClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ArtefactService_StreamHTTPClient interface {
	Recv() (*h2gproxy.StreamDataResponse, error)
	grpc.ClientStream
}

type artefactServiceStreamHTTPClient struct {
	grpc.ClientStream
}

func (x *artefactServiceStreamHTTPClient) Recv() (*h2gproxy.StreamDataResponse, error) {
	m := new(h2gproxy.StreamDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *artefactServiceClient) GetFile(ctx context.Context, in *Reference, opts ...grpc.CallOption) (ArtefactService_GetFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ArtefactService_serviceDesc.Streams[1], c.cc, "/artefact.ArtefactService/GetFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &artefactServiceGetFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ArtefactService_GetFileClient interface {
	Recv() (*h2gproxy.StreamDataResponse, error)
	grpc.ClientStream
}

type artefactServiceGetFileClient struct {
	grpc.ClientStream
}

func (x *artefactServiceGetFileClient) Recv() (*h2gproxy.StreamDataResponse, error) {
	m := new(h2gproxy.StreamDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *artefactServiceClient) SetAccess(ctx context.Context, in *SetAccessRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/SetAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) Find(ctx context.Context, in *FindRequest, opts ...grpc.CallOption) (*ArtefactList, error) {
	out := new(ArtefactList)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/Find", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) GetRepoVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*Contents, error) {
	out := new(Contents)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/GetRepoVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) GetArtefactBuilds(ctx context.Context, in *ArtefactID, opts ...grpc.CallOption) (*BuildList, error) {
	out := new(BuildList)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/GetArtefactBuilds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) GetDirListing(ctx context.Context, in *DirListRequest, opts ...grpc.CallOption) (*DirListing, error) {
	out := new(DirListing)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/GetDirListing", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) GetFileStream(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (ArtefactService_GetFileStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ArtefactService_serviceDesc.Streams[2], c.cc, "/artefact.ArtefactService/GetFileStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &artefactServiceGetFileStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ArtefactService_GetFileStreamClient interface {
	Recv() (*FileStreamResponse, error)
	grpc.ClientStream
}

type artefactServiceGetFileStreamClient struct {
	grpc.ClientStream
}

func (x *artefactServiceGetFileStreamClient) Recv() (*FileStreamResponse, error) {
	m := new(FileStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *artefactServiceClient) DoesFileExist(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (*FileExistsInfo, error) {
	out := new(FileExistsInfo)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/DoesFileExist", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) GetRepoForArtefact(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/GetRepoForArtefact", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) GetArtefactForRepo(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/GetArtefactForRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) GetArtefactByID(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ArtefactID, error) {
	out := new(ArtefactID)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/GetArtefactByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) GetArtefactIDForRepo(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ArtefactID, error) {
	out := new(ArtefactID)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/GetArtefactIDForRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) MetaByID(ctx context.Context, in *ID, opts ...grpc.CallOption) (*ArtefactMeta, error) {
	out := new(ArtefactMeta)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/MetaByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) CreateArtefactIfRequired(ctx context.Context, in *CreateArtefactRequest, opts ...grpc.CallOption) (*CreateArtefactResponse, error) {
	out := new(CreateArtefactResponse)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/CreateArtefactIfRequired", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ArtefactService service

type ArtefactServiceServer interface {
	// list *latest* version of all artefacts (for this user)
	List(context.Context, *common.Void) (*ArtefactList, error)
	// get contents of a directory or artefact.
	GetContents(context.Context, *Reference) (*Contents, error)
	// download a file via http
	StreamHTTP(*h2gproxy.StreamRequest, ArtefactService_StreamHTTPServer) error
	// download a file via gRPC stream
	GetFile(*Reference, ArtefactService_GetFileServer) error
	// set access to a repo/artefact
	SetAccess(context.Context, *SetAccessRequest) (*common.Void, error)
	// finds artefacts based on fuzzy string matches
	Find(context.Context, *FindRequest) (*ArtefactList, error)
	// get a specific version of a repository
	GetRepoVersion(context.Context, *GetVersionRequest) (*Contents, error)
	// get builds for a given artefact
	GetArtefactBuilds(context.Context, *ArtefactID) (*BuildList, error)
	// get list of files for a given artefact, build and directory
	GetDirListing(context.Context, *DirListRequest) (*DirListing, error)
	// get a file as stream
	GetFileStream(*FileRequest, ArtefactService_GetFileStreamServer) error
	// does file exist
	DoesFileExist(context.Context, *FileRequest) (*FileExistsInfo, error)
	// get which repo fed this artefact
	GetRepoForArtefact(context.Context, *ID) (*ID, error)
	// get an artefact for a given repo
	GetArtefactForRepo(context.Context, *ID) (*ID, error)
	// get an artefact for a given repo
	GetArtefactByID(context.Context, *ID) (*ArtefactID, error)
	// get an artefactid for a given repo
	GetArtefactIDForRepo(context.Context, *ID) (*ArtefactID, error)
	// get artefact metadata by artefactid
	MetaByID(context.Context, *ID) (*ArtefactMeta, error)
	// create artefact if required. if it exists already it will not be recreated. URL may be added or updated
	CreateArtefactIfRequired(context.Context, *CreateArtefactRequest) (*CreateArtefactResponse, error)
}

func RegisterArtefactServiceServer(s *grpc.Server, srv ArtefactServiceServer) {
	s.RegisterService(&_ArtefactService_serviceDesc, srv)
}

func _ArtefactService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).List(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_GetContents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).GetContents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/GetContents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).GetContents(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_StreamHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(h2gproxy.StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ArtefactServiceServer).StreamHTTP(m, &artefactServiceStreamHTTPServer{stream})
}

type ArtefactService_StreamHTTPServer interface {
	Send(*h2gproxy.StreamDataResponse) error
	grpc.ServerStream
}

type artefactServiceStreamHTTPServer struct {
	grpc.ServerStream
}

func (x *artefactServiceStreamHTTPServer) Send(m *h2gproxy.StreamDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ArtefactService_GetFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Reference)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ArtefactServiceServer).GetFile(m, &artefactServiceGetFileServer{stream})
}

type ArtefactService_GetFileServer interface {
	Send(*h2gproxy.StreamDataResponse) error
	grpc.ServerStream
}

type artefactServiceGetFileServer struct {
	grpc.ServerStream
}

func (x *artefactServiceGetFileServer) Send(m *h2gproxy.StreamDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ArtefactService_SetAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).SetAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/SetAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).SetAccess(ctx, req.(*SetAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/Find",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).Find(ctx, req.(*FindRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_GetRepoVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).GetRepoVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/GetRepoVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).GetRepoVersion(ctx, req.(*GetVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_GetArtefactBuilds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArtefactID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).GetArtefactBuilds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/GetArtefactBuilds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).GetArtefactBuilds(ctx, req.(*ArtefactID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_GetDirListing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DirListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).GetDirListing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/GetDirListing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).GetDirListing(ctx, req.(*DirListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_GetFileStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ArtefactServiceServer).GetFileStream(m, &artefactServiceGetFileStreamServer{stream})
}

type ArtefactService_GetFileStreamServer interface {
	Send(*FileStreamResponse) error
	grpc.ServerStream
}

type artefactServiceGetFileStreamServer struct {
	grpc.ServerStream
}

func (x *artefactServiceGetFileStreamServer) Send(m *FileStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ArtefactService_DoesFileExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).DoesFileExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/DoesFileExist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).DoesFileExist(ctx, req.(*FileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_GetRepoForArtefact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).GetRepoForArtefact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/GetRepoForArtefact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).GetRepoForArtefact(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_GetArtefactForRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).GetArtefactForRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/GetArtefactForRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).GetArtefactForRepo(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_GetArtefactByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).GetArtefactByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/GetArtefactByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).GetArtefactByID(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_GetArtefactIDForRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).GetArtefactIDForRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/GetArtefactIDForRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).GetArtefactIDForRepo(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_MetaByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).MetaByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/MetaByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).MetaByID(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_CreateArtefactIfRequired_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateArtefactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).CreateArtefactIfRequired(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/CreateArtefactIfRequired",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).CreateArtefactIfRequired(ctx, req.(*CreateArtefactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ArtefactService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "artefact.ArtefactService",
	HandlerType: (*ArtefactServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _ArtefactService_List_Handler,
		},
		{
			MethodName: "GetContents",
			Handler:    _ArtefactService_GetContents_Handler,
		},
		{
			MethodName: "SetAccess",
			Handler:    _ArtefactService_SetAccess_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _ArtefactService_Find_Handler,
		},
		{
			MethodName: "GetRepoVersion",
			Handler:    _ArtefactService_GetRepoVersion_Handler,
		},
		{
			MethodName: "GetArtefactBuilds",
			Handler:    _ArtefactService_GetArtefactBuilds_Handler,
		},
		{
			MethodName: "GetDirListing",
			Handler:    _ArtefactService_GetDirListing_Handler,
		},
		{
			MethodName: "DoesFileExist",
			Handler:    _ArtefactService_DoesFileExist_Handler,
		},
		{
			MethodName: "GetRepoForArtefact",
			Handler:    _ArtefactService_GetRepoForArtefact_Handler,
		},
		{
			MethodName: "GetArtefactForRepo",
			Handler:    _ArtefactService_GetArtefactForRepo_Handler,
		},
		{
			MethodName: "GetArtefactByID",
			Handler:    _ArtefactService_GetArtefactByID_Handler,
		},
		{
			MethodName: "GetArtefactIDForRepo",
			Handler:    _ArtefactService_GetArtefactIDForRepo_Handler,
		},
		{
			MethodName: "MetaByID",
			Handler:    _ArtefactService_MetaByID_Handler,
		},
		{
			MethodName: "CreateArtefactIfRequired",
			Handler:    _ArtefactService_CreateArtefactIfRequired_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamHTTP",
			Handler:       _ArtefactService_StreamHTTP_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetFile",
			Handler:       _ArtefactService_GetFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetFileStream",
			Handler:       _ArtefactService_GetFileStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protos/golang.conradwood.net/apis/artefact/artefact.proto",
}

func init() {
	proto.RegisterFile("protos/golang.conradwood.net/apis/artefact/artefact.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1334 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x57, 0x6d, 0x6f, 0x1b, 0xc5,
	0x13, 0xff, 0x9f, 0x7d, 0x89, 0xed, 0xb1, 0xe3, 0xb8, 0xfb, 0x4f, 0xc2, 0xc9, 0x54, 0xc5, 0xba,
	0x02, 0x72, 0x1f, 0xe4, 0x04, 0xd3, 0x22, 0x51, 0x50, 0xdb, 0xb4, 0xd7, 0x18, 0x57, 0x29, 0x54,
	0x9b, 0xb4, 0x82, 0x4a, 0x80, 0xae, 0xf6, 0x26, 0x5d, 0x61, 0xdf, 0x86, 0xbd, 0xed, 0x43, 0xf8,
	0x16, 0x7c, 0x05, 0x24, 0x5e, 0xf2, 0x55, 0xf8, 0x4c, 0x68, 0x9f, 0xee, 0xf6, 0xec, 0x73, 0x8a,
	0xc4, 0x2b, 0xef, 0xcc, 0xce, 0xe3, 0x6f, 0xe6, 0x66, 0xd6, 0xf0, 0xe5, 0x19, 0x67, 0x82, 0xa5,
	0xbb, 0xa7, 0x6c, 0x16, 0x27, 0xa7, 0x83, 0x09, 0x4b, 0x78, 0x3c, 0x7d, 0xcb, 0xd8, 0x74, 0x90,
	0x10, 0xb1, 0x1b, 0x9f, 0xd1, 0x74, 0x37, 0xe6, 0x82, 0x9c, 0xc4, 0x13, 0x91, 0x1d, 0x06, 0x4a,
	0x07, 0xd5, 0x2d, 0xdd, 0x1d, 0x5c, 0xa0, 0x3d, 0x61, 0xf3, 0x39, 0x4b, 0xcc, 0x8f, 0xd6, 0xec,
	0x0e, 0x2f, 0x90, 0x7f, 0x35, 0x3c, 0x3d, 0xe3, 0xec, 0xdd, 0x79, 0x76, 0xd0, 0x3a, 0xe1, 0x7d,
	0x68, 0xed, 0x1b, 0x7f, 0x87, 0x34, 0x15, 0x68, 0x0f, 0x1a, 0x96, 0x4e, 0x03, 0xaf, 0x57, 0xed,
	0x37, 0x87, 0x68, 0x90, 0x45, 0xf8, 0x90, 0x25, 0x82, 0x24, 0x22, 0xc5, 0xb9, 0x50, 0xb8, 0x0b,
	0x9b, 0x11, 0x7b, 0x9b, 0xcc, 0x58, 0x3c, 0xc5, 0xe4, 0xd7, 0xd7, 0x24, 0x15, 0xe8, 0x32, 0x34,
	0x30, 0x39, 0x21, 0x9c, 0x24, 0x13, 0x12, 0x78, 0x3d, 0xaf, 0xdf, 0xc0, 0x39, 0x23, 0xec, 0x01,
	0x1c, 0xd0, 0x19, 0x39, 0x12, 0x9c, 0xc4, 0x73, 0x84, 0xc0, 0x8f, 0x62, 0x11, 0x2b, 0xb1, 0x16,
	0x56, 0xe7, 0xf0, 0x9a, 0xa3, 0xff, 0x1e, 0x63, 0x5f, 0x41, 0xd3, 0x86, 0x82, 0xc9, 0x89, 0xb4,
	0xf6, 0x6d, 0x3c, 0xb7, 0x72, 0xea, 0x8c, 0x02, 0xa8, 0x3d, 0x27, 0x3c, 0xa5, 0x2c, 0x09, 0x2a,
	0x3d, 0xaf, 0xef, 0x63, 0x4b, 0x86, 0xbf, 0x7b, 0xb0, 0x79, 0x44, 0x38, 0x8d, 0x67, 0xb9, 0xbb,
	0x00, 0x6a, 0x98, 0x9c, 0x1c, 0x9f, 0x9f, 0x69, 0x23, 0x1b, 0xd8, 0x92, 0xab, 0xed, 0xa0, 0x2d,
	0x58, 0x3b, 0x26, 0xef, 0x44, 0x1a, 0x54, 0x7b, 0xd5, 0x7e, 0x03, 0x6b, 0x02, 0xed, 0xc0, 0x7a,
	0xc4, 0xe6, 0x31, 0x4d, 0x02, 0x5f, 0x45, 0x63, 0x28, 0x99, 0xd0, 0x83, 0xd7, 0x74, 0x36, 0xc5,
	0xe4, 0x8c, 0x05, 0x6b, 0x3a, 0xa1, 0x8c, 0x11, 0xfe, 0xed, 0x43, 0xdd, 0xc2, 0x8c, 0xae, 0x43,
	0x27, 0x8b, 0xcc, 0xfa, 0xd6, 0xa9, 0x2d, 0xf1, 0x51, 0x1f, 0x36, 0x33, 0xde, 0x61, 0x2c, 0x48,
	0x2a, 0x54, 0x98, 0x0d, 0xbc, 0xc8, 0x46, 0x37, 0xa1, 0xf6, 0x28, 0x11, 0x9c, 0x12, 0x1d, 0x70,
	0x79, 0x85, 0xad, 0x48, 0x06, 0xa9, 0x5f, 0x0e, 0xe9, 0x5a, 0x11, 0x8a, 0x1e, 0x34, 0xf7, 0xa7,
	0x73, 0x9a, 0xec, 0x4f, 0x26, 0x24, 0x4d, 0x83, 0xf5, 0x9e, 0xd7, 0xaf, 0x63, 0x97, 0x85, 0xae,
	0x81, 0xaf, 0xd0, 0xad, 0xf5, 0xbc, 0x7e, 0x7b, 0xb8, 0xbd, 0xe4, 0x5a, 0x5e, 0x62, 0x25, 0x82,
	0x3e, 0x83, 0xba, 0x2d, 0x6e, 0x50, 0xef, 0x79, 0xfd, 0xa6, 0x2b, 0xee, 0x94, 0x1d, 0x67, 0x62,
	0x32, 0xda, 0xa7, 0xb1, 0x78, 0x15, 0x34, 0x74, 0xb4, 0xf2, 0x8c, 0x42, 0x68, 0xd9, 0x0e, 0x8d,
	0x5f, 0xce, 0x48, 0x00, 0x2a, 0xa8, 0x02, 0xcf, 0x29, 0x56, 0xb3, 0x50, 0xac, 0x5b, 0x00, 0xd6,
	0xf6, 0x38, 0x0a, 0x5a, 0x2a, 0x88, 0xad, 0xe5, 0x20, 0xc6, 0x11, 0x76, 0xe4, 0x8a, 0x25, 0xde,
	0x58, 0x28, 0xb1, 0x8c, 0x47, 0xfe, 0xa6, 0x54, 0x30, 0x7e, 0x3e, 0x8e, 0x82, 0xb6, 0x82, 0xb0,
	0xc0, 0x43, 0x1f, 0xc3, 0xc6, 0x21, 0x4d, 0x7e, 0x39, 0x66, 0x16, 0xe7, 0x4d, 0x65, 0xa5, 0xc8,
	0x94, 0x96, 0x34, 0xc3, 0x14, 0xbc, 0xa3, 0x84, 0x0a, 0xbc, 0x70, 0x0e, 0x9d, 0x23, 0x22, 0x34,
	0xf8, 0xf6, 0x03, 0xbd, 0x01, 0xeb, 0xc7, 0x31, 0x3f, 0x25, 0x42, 0x75, 0x53, 0x73, 0xf8, 0xff,
	0x3c, 0xa3, 0xac, 0x59, 0xb0, 0x11, 0x91, 0xd0, 0x3c, 0x4b, 0x09, 0x1f, 0x47, 0xa6, 0x9f, 0x0c,
	0x25, 0xbb, 0x7e, 0xc4, 0xe3, 0x44, 0x04, 0x55, 0x85, 0xa7, 0x26, 0xc2, 0x1b, 0xd0, 0x3c, 0xa0,
	0x89, 0x3b, 0x0a, 0x64, 0xc7, 0x3c, 0x89, 0xc5, 0xe4, 0x95, 0xfd, 0x7a, 0x33, 0x46, 0xf8, 0x03,
	0x5c, 0x1a, 0x11, 0x61, 0xb2, 0xb1, 0x2a, 0x65, 0xdf, 0x70, 0x5e, 0x9e, 0x4a, 0xa1, 0x3c, 0x4e,
	0x23, 0x56, 0x8b, 0xdf, 0xf6, 0x55, 0x53, 0x02, 0x35, 0xd5, 0x76, 0x60, 0x5d, 0x11, 0x7a, 0xa4,
	0xf9, 0xd8, 0x50, 0xe1, 0xf7, 0xd0, 0x8e, 0x28, 0x97, 0x22, 0xd6, 0xf9, 0x16, 0xac, 0xa9, 0x3b,
	0xe5, 0xdd, 0xc7, 0x9a, 0x40, 0x1d, 0xa8, 0x46, 0x94, 0x1b, 0xdf, 0xf2, 0x88, 0xae, 0x14, 0xfa,
	0x42, 0xfb, 0x76, 0x38, 0xe1, 0xcf, 0x12, 0x86, 0x19, 0xb1, 0x66, 0x8b, 0xe2, 0xde, 0xa2, 0x78,
	0xee, 0xb6, 0xe2, 0xba, 0xed, 0x42, 0x5d, 0x1a, 0x49, 0x24, 0x1a, 0x55, 0xe5, 0x3b, 0xa3, 0xc3,
	0xfb, 0xfa, 0x6e, 0x9c, 0x9c, 0xb0, 0x52, 0xc4, 0x7a, 0xd0, 0xc4, 0x64, 0x16, 0x0b, 0xfa, 0x86,
	0xe4, 0xa1, 0xbb, 0xac, 0xf0, 0x1e, 0xd4, 0x22, 0xca, 0xff, 0x83, 0x81, 0x61, 0xbe, 0x3b, 0x94,
	0x95, 0x36, 0x54, 0xb2, 0xe4, 0x2a, 0xe3, 0x28, 0xb3, 0x5a, 0xc9, 0xad, 0x86, 0x7f, 0x79, 0x00,
	0x06, 0x72, 0x9a, 0x9c, 0xa2, 0x3e, 0xac, 0xc9, 0x2c, 0x4a, 0x56, 0x8d, 0x4d, 0x0e, 0x6b, 0x01,
	0xf4, 0x09, 0xf8, 0x11, 0xe5, 0x69, 0x50, 0x51, 0x82, 0x97, 0x72, 0x41, 0x93, 0x03, 0x56, 0xd7,
	0xe8, 0x4e, 0x31, 0x26, 0x05, 0x5b, 0x73, 0xb8, 0x53, 0xf2, 0xc5, 0x4a, 0x9d, 0x62, 0xfc, 0x76,
	0x76, 0xf8, 0xf9, 0xec, 0x08, 0x1f, 0x03, 0xca, 0x97, 0x15, 0x26, 0xe9, 0x19, 0x4b, 0x52, 0x62,
	0x0b, 0x93, 0xd2, 0xdf, 0x88, 0xc9, 0x37, 0xa3, 0x65, 0x4b, 0x3e, 0x8d, 0xcf, 0xe5, 0x60, 0x51,
	0x89, 0xb7, 0xb0, 0x25, 0xc3, 0xaf, 0xa1, 0x2d, 0xa5, 0x1e, 0xbd, 0xa3, 0xa9, 0x48, 0x95, 0xc7,
	0x1d, 0x58, 0xd7, 0x94, 0xb2, 0x52, 0xc7, 0x86, 0x92, 0x91, 0x1c, 0x49, 0xdb, 0xba, 0x1b, 0xd4,
	0x39, 0xdc, 0x92, 0xe8, 0x2e, 0x62, 0x1c, 0xbe, 0x70, 0x1b, 0x6b, 0xa9, 0x02, 0xab, 0x3e, 0x1b,
	0x5b, 0x99, 0xaa, 0x53, 0xef, 0x0e, 0x54, 0x9f, 0xe1, 0x43, 0x93, 0xbc, 0x3c, 0x86, 0x57, 0x72,
	0x2c, 0x9f, 0x10, 0x11, 0x2f, 0xf9, 0xfe, 0xd3, 0x83, 0xed, 0x87, 0x9c, 0xc4, 0x82, 0xe4, 0xb3,
	0x58, 0xb7, 0xfb, 0xa7, 0xd0, 0xfe, 0x8e, 0x9f, 0xc6, 0x09, 0x4d, 0x63, 0x41, 0x59, 0x62, 0xb4,
	0x1a, 0x78, 0x81, 0x2b, 0xe7, 0x97, 0x55, 0x75, 0x3a, 0xa5, 0xc0, 0x93, 0x7b, 0x2d, 0x1b, 0x9d,
	0x26, 0x19, 0x1d, 0xf6, 0x22, 0x5b, 0x66, 0x3b, 0xa2, 0x22, 0x4f, 0xc2, 0x50, 0xe1, 0x4f, 0xb0,
	0xb3, 0x18, 0xa6, 0xa9, 0x63, 0x00, 0x35, 0x7d, 0x33, 0x35, 0x05, 0xb0, 0x24, 0xba, 0x0e, 0xbe,
	0xcc, 0x59, 0x45, 0x54, 0xda, 0x3f, 0xf2, 0x16, 0x2b, 0x99, 0xeb, 0xb7, 0xa0, 0xe9, 0xec, 0x2e,
	0xb4, 0x01, 0x8d, 0x88, 0x72, 0x32, 0x91, 0x93, 0xbc, 0xf3, 0x3f, 0x54, 0x07, 0x5f, 0x56, 0xbd,
	0xe3, 0xa1, 0x56, 0xbe, 0xce, 0x3a, 0x95, 0xe1, 0x1f, 0x75, 0xd8, 0xb4, 0xe4, 0x11, 0xe1, 0x6f,
	0xe8, 0x84, 0xa0, 0x9b, 0xe0, 0xab, 0x79, 0xd5, 0x1a, 0x98, 0x87, 0xdd, 0x73, 0x46, 0xa7, 0xdd,
	0x12, 0xef, 0x4a, 0xea, 0x0b, 0x68, 0x8e, 0x88, 0xc8, 0x1e, 0x0b, 0x65, 0x43, 0xbc, 0x5b, 0xb2,
	0xda, 0xd1, 0x23, 0x00, 0xdd, 0xcf, 0xdf, 0x1c, 0x1f, 0x3f, 0x45, 0x1f, 0x0c, 0xb2, 0x27, 0xa1,
	0xed, 0x72, 0x55, 0xc4, 0xee, 0xe5, 0xc5, 0x0b, 0xf9, 0x36, 0xb3, 0xd0, 0xed, 0x79, 0xe8, 0x2e,
	0xd4, 0x46, 0x44, 0xc8, 0xdc, 0xca, 0x5d, 0xbf, 0x4f, 0xff, 0x36, 0x34, 0xb2, 0xc5, 0x84, 0xba,
	0xb9, 0x85, 0xc5, 0x6d, 0xd5, 0x2d, 0xa0, 0x81, 0x6e, 0x4b, 0x3c, 0x93, 0x29, 0xda, 0x76, 0x67,
	0x45, 0xb6, 0x70, 0x56, 0x82, 0xb5, 0x0f, 0xed, 0x11, 0x11, 0xb2, 0x5b, 0xec, 0xf2, 0xfc, 0x30,
	0x97, 0x5c, 0x5a, 0x42, 0xa5, 0xb8, 0xdd, 0x55, 0xdb, 0xca, 0x5a, 0xd5, 0x2b, 0x04, 0x95, 0x3e,
	0x06, 0xba, 0x0e, 0x20, 0xf9, 0x16, 0xba, 0x07, 0x1b, 0x23, 0x22, 0x9c, 0xe9, 0x17, 0x14, 0xa6,
	0x98, 0xb3, 0x86, 0xba, 0x5b, 0x4b, 0x37, 0x52, 0xfe, 0x40, 0x19, 0x70, 0x1e, 0xcf, 0xdb, 0xc5,
	0x79, 0x99, 0x57, 0xae, 0xc0, 0x2e, 0x0e, 0xaf, 0x3d, 0x0f, 0xdd, 0x87, 0x8d, 0x88, 0x91, 0x34,
	0x1b, 0x46, 0xab, 0xec, 0x04, 0x45, 0xb6, 0x33, 0xb8, 0xf6, 0x00, 0x19, 0x34, 0x0f, 0x18, 0xcf,
	0x1e, 0x5f, 0xad, 0x5c, 0x7e, 0x1c, 0x75, 0x0b, 0x94, 0xd1, 0xb0, 0xa2, 0x07, 0x8c, 0xab, 0xa7,
	0xd0, 0x45, 0x1a, 0xb7, 0x61, 0xd3, 0x85, 0x5b, 0xbe, 0x8a, 0x8a, 0xe2, 0xa5, 0xd0, 0xa3, 0x3b,
	0xb0, 0xe5, 0xa8, 0x8d, 0xa3, 0x72, 0x57, 0xe5, 0xba, 0x7b, 0x50, 0x97, 0x5f, 0x74, 0x89, 0xaf,
	0x15, 0x13, 0x00, 0xfd, 0x08, 0x41, 0x71, 0xb6, 0x8c, 0x4f, 0x24, 0x7a, 0x94, 0x93, 0x29, 0xfa,
	0xc8, 0xe9, 0xa1, 0xb2, 0x31, 0xd9, 0xed, 0xad, 0x16, 0xd0, 0xb5, 0x7a, 0xf0, 0x18, 0xae, 0x26,
	0x44, 0xb8, 0xff, 0xe8, 0xcc, 0x7f, 0x3c, 0xf9, 0xa7, 0x2e, 0xd3, 0x7e, 0x71, 0xf5, 0x5f, 0xfc,
	0xcf, 0x7c, 0xb9, 0xae, 0xfe, 0xf1, 0x7d, 0xfe, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x25, 0x50,
	0x2d, 0x0e, 0x9c, 0x0e, 0x00, 0x00,
}




